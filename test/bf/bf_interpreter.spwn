RIGHT = ?b // >
LEFT = ?b  // <
INCR = ?b  // +
DECR = ?b  // -
DOT = ?b   // .
INPUT = ?b // ,
OPEN = ?b  // [
CLOSE = ?b // ]

END = ?b   //end of the program
NOOP = ?b  //NO OPERATION

spacing = 10
extract obj_props
gs = {
    hidden_group: 976g,
    button_a: () {
		return collision(162b, 163b)
	},
	button_b: () {
		return touch(dual_side = true)
	},
}

abs = (num) {
    if num < 0 {
        return -num
    } else {
        return num
    }

}
import "text_display.spwn"

gamemode = counter(20i) // 0 = tutorial, 1 = challenge, 2 = coins, 3 = sandbox
started = counter(0)
challenge = counter(556i)
random_seed = counter(500i)
random_bg_seed = counter(601i)
bg_options = 2
bg_part = counter()

challenges = 9
input_choice = counter()
input_choice2 = counter()

ended = counter(0)

bg_option1 = counter(800i)
bg_option2 = counter(801i)

message_board = 931g

game_bgs = [[906g, 907g, ?g], [910g, 911g, ?g], [912g, 913g, ?g],  [940g, 941g, ?g], [970g, 971g, ?g], ]
random_max = 4
auto_inputs = [1,3,10,13] // 2.25
auto_inputs2 = [2,3,6,8] // 0.5, 0.5, 0.5, 0.25

// runs in a row, level complete,
messages = [804c, 808c, 809c, 900c, 850c]


bc = [77, 93, 97]

left_buttons = [193c, 195c, 191c, 196c, 803c]

right_buttons = [192c, 194c,  802c, 212c]

activate_button = (activate, deactivate) {

    let colors = []



    if activate != null {
        if left_buttons.contains(activate) {
            colors = left_buttons
        } else {
            colors = right_buttons
        }
        for col in colors {
            if col == activate {
                -> col.set(bc[0], bc[1], bc[2], 0)
            } else {
                -> col.set(0, 0, 0, 0, blending = true)
            }
        }
    } else if deactivate != null {
        if left_buttons.contains(deactivate) {
            colors = left_buttons
        } else {
            colors = right_buttons
        }
        for col in colors {
            -> col.set(0, 0, 0, 0, blending = true)
        }
    }

}

successful_runs = counter(555i)

reset_runs_in_a_row = !{
    num = successful_runs.to_const(1..4)
    successful_runs -= num
    -> 962g.move(200 * num, 0, 0)
} // fully functional programming language inside geometry dash

type @bfreader
layers = counter(600i)
//layers.display(150, 300)
cell_pointer = 20g
input_layer = 21g

prog_pointer = 23g
prog_selector = 24g
force_stop_layer = 25g
input_layer.alpha(0)
//finished_layer.alpha(0)
force_stop_layer.alpha(0)

msg_board_anim = !{
    -> 963g.move(0, -20, 1, easing = EXPONENTIAL_OUT)
    wait(2)
    -> 963g.move(0, 20, 1, easing = EXPONENTIAL_IN)
}

top_msg_board = (message, color) {
    msg_board_anim!

    for i in ..messages.length {
        if i == message {
            //-> messages[i].set(0,0,0, 0, blending = false)
            -> messages[i].set(color[0], color[1], color[2], 1, blending = false)
        } else {
            -> messages[i].set(0,0,0, 0, blending = true)
        }
    }
}


bottom_msg_board_up = (){
    -> message_board.move(0, 10, 1, easing = EXPONENTIAL_OUT)
    -> 216c.set(255, 255, 255, 1)
    -> 942g.move(0, 30, 0.5, easing = EXPONENTIAL_OUT)
}

bottom_msg_board_down = (){
    -> message_board.move(0, -10, 1, easing = EXPONENTIAL_IN)
    -> 216c.set(0, 0, 0, 1)
    -> 942g.move(0, -30, 0.5, easing = EXPONENTIAL_IN)
}

input_char = 26g

tut_page = 965g
tut_page_num = counter(0)
tut_pages = 8

move_button = 10c
select_button = 11c

input_inc_button = 12c
input_done_button = 13c

input_mode = counter()
//input_mode.display(120, 30)

input_used = counter(0)
//input_used.display(90, 30)

prog_ptr_color = [94, 13, 13]
45c.set(prog_ptr_color[0], prog_ptr_color[1], prog_ptr_color[2], blending = true)

pulse_ptr = (){
    -> 972g.move(0, 1, 0.05, easing = EASE_IN)
    -> 973g.move(0, -1, 0.05, easing = EASE_IN)
    -> 974g.move(1, 0, 0.05, easing = EASE_IN)
    -> 975g.move(-1, 0, 0.05, easing = EASE_IN)

    -> 972g.move(0, -1, 0.2, easing = EASE_IN_OUT)
    -> 973g.move(0, 1, 0.2, easing = EASE_IN_OUT)
    -> 974g.move(-1, 0, 0.2, easing = EASE_IN_OUT)
    -> 975g.move(1, 0, 0.2, easing = EASE_IN_OUT)
}

// win_condition = "win"
// coin_condition = "coin tu"

mem_items = [62i, 54i, 63i, 64i, 58i, 55i, 65i, 60i, 59i, 66i]


force_stop = !{
    -> 45c.set(prog_ptr_color[0], prog_ptr_color[1], prog_ptr_color[2], blending = true)
    bottom_msg_board_up()
    top_msg_board(3, [255, 255, 255])
    //-> finished_color.set(255, 255, 255, 0)
    ended += 1
    -> if successful_runs > 0 {
        reset_runs_in_a_row!
        top_msg_board(0, [255, 0, 0])
    }
}

impl @bfreader {
    new: (script_offset: [@number], cell_count: @number) {

        std_out = @textdisplay::new([script_offset[0] + 1278, script_offset[1] - 66], 10)
        //$.print("hello")
        //-> BG.pulse(255, 0, 0, fade_out = 0.5)
        //-> std_out.write(counter(5))



        block = ?b
        group = ?g
        $.add(obj {
            OBJ_ID: 1816,
            X: script_offset[0] - spacing * 3,
            Y: script_offset[1],
            GROUPS: [group, gs.hidden_group],
            BLOCK_A: block,
            SCALING: 0.5,
            DYNAMIC_BLOCK: true,
        })
        // for b in [RIGHT,LEFT,INCR,DECR,DOT,OPEN,CLOSE] {
        //     $.add(obj {
        //         OBJ_ID: 1816,
        //         X: script_offset[0] - spacing * 3,
        //         Y: script_offset[1],
        //         SCALING: 0.5,
        //         BLOCK_A: b,
        //     })
        // }

        //start point
        start_point = ?g
        $.add(obj {
            OBJ_ID: 1765,
            X: script_offset[0] - spacing * 3,
            Y: script_offset[1],
            GROUPS: start_point
        })


        // CREATE CELLS
        let cells = []
        for i in ..cell_count {
            c = counter(mem_items[i])
            cells.push(c)
            //c.display(script_offset[0] + i * 30 + 300, script_offset[1] + 690)
        }
        ptr = counter(0)
        //ptr.display(script_offset[0], script_offset[1] + 60)
        std_in = counter(85i)
        //std_in.display(script_offset[0], script_offset[1] - 90)



        num_out = counter(61i)
        num_out.display(script_offset[0], script_offset[1] + 210)
        out = @bfreader::{
            group: group,
            right: counter(block.create_tracker_item(RIGHT), bits = 1),
            left:  counter(block.create_tracker_item(LEFT), bits = 1),
            incr:  counter(block.create_tracker_item(INCR), bits = 1),
            dot:   counter(block.create_tracker_item(DOT), bits = 1),
            input: counter(block.create_tracker_item(INPUT), bits = 1),
            decr:  counter(block.create_tracker_item(DECR), bits = 1),
            open:  counter(block.create_tracker_item(OPEN), bits = 1),
            close: counter(block.create_tracker_item(CLOSE), bits = 1),
            end:   counter(block.create_tracker_item(END), bits = 1),
            noop:  counter(block.create_tracker_item(NOOP), bits = 1),
            std_out: std_out,
            num_out: num_out,
            std_in: std_in,
            ptr: ptr,
            cells: cells,
            start_point: start_point
        }


        return out
    },
    // currently_on: (self) {
    //     if self.right == 1 {
    //         return RIGHT
    //     }
    //     if self.left == 1 {
    //         return LEFT
    //     }
    //     if self.incr == 1 {
    //         return INCR
    //     }
    //     if self.decr == 1 {
    //         return DECR
    //     }
    //     if self.dot == 1 {
    //         return DOT
    //     }
    //     if self.input == 1 {
    //         return INPUT
    //     }
    //     if self.open == 1 {
    //         return OPEN
    //     } if self.close == 1 {
    //         return CLOSE
    //     } if self.noop == 1 {
    //         return NOOP
    //     }
    // },
    current_cell: (self) => self.cells[self.ptr.to_const(..self.cells.length)],
    interpret: (self) {

        ret = !{
            suppress_signal(0.05)
            -> self.group.move(spacing, 0, 0)
            -> return
        }

        fast_ret = !{
            -> self.group.move(spacing, 0, 0)
            -> return
        }

        slow_ret =  !{
            suppress_signal(0.1)
            wait(0.1)
            -> self.group.move(spacing, 0, 0)
            -> return
        }

        // slow_ret = !{
        //     suppress_signal(0.06)
        //     ret!
        // }



        -> if @bool(self.right) {

            if self.ptr == self.cells.length - 1 {
                wait()
                self.ptr -= self.cells.length - 1
                -> cell_pointer.move(-10 * (self.cells.length - 1),0, 0.1)
                ret!
            } else {
                wait()
                self.ptr += 1
                -> cell_pointer.move(10,0, 0.1)
                ret!
            }


        }
        -> if @bool(self.left) {
            if self.ptr == 0 {
                wait()
                self.ptr += self.cells.length - 1
                -> cell_pointer.move(10 * (self.cells.length - 1), 0, 0.1)
                ret!
            } else {
                wait()
                self.ptr -= 1
                -> cell_pointer.move(-10,0, 0.1)
                ret!
            }

        }
        -> if @bool(self.incr) {
            -> self.current_cell() += 1
            pulse_ptr()
            fast_ret!
        }
        -> if @bool(self.decr) {
            -> (){
                cell = self.current_cell()
                //$.print(current)
                if cell > 0 {
                    cell -= 1
                }
            }()
            pulse_ptr()
            fast_ret!
        }
        -> if @bool(self.dot) {

            () {
                self.num_out.reset()
                cell = self.current_cell()
                //wait()
                cell.copy_to([self.num_out], )
            } ()
            suppress_signal(0.1) // DO NOT REMOVE VERY IMPORTANT APPARENTLY
            // REQUIRED FOR TEXT TO WORK ON MOBILE FOR SOME REASON

            self.std_out.write(self.num_out, )

            slow_ret!
        }
        -> if @bool(self.input) {
            //suppress_signal(0.1)
            std_in = self.std_in
            -> input_layer.alpha(1, 0.5)

            auto_input_challenges = [3, 4, 5]

            manual_input = !{
                activate_button(802c, null)
                activate_button(803c, null)
                input_mode += 1
            }

            done = !{
                -> if input_used < 2 {
                    input_used += 1
                }
                activate_button(null, 802c)
                activate_button(null, 803c)

                -> input_done_button.pulse(52, 247, 68, fade_out = 0.3)
                -> input_layer.alpha(0, 0.5)
                cell = self.current_cell()
                cell.reset()
                std_in.add_to([cell], for_each = (n){ input_char.move(100 * n, 0, 0) })

                slow_ret!
            }

            auto_input = !{
                -> 801c.pulse(255, 255, 255, hold = 2.1)
                -> 214c.pulse(0,0,0, hold = 2.1)
                wait(0.5)
                choice = random_seed.to_const(0..random_max)
                input_used.item.if_is(EQUAL_TO, 0, !{
                    input_choice += choice
                    std_in += auto_inputs[choice]
                    input_char.move(-100 * auto_inputs[choice], 0, 0)
                })
                input_used.item.if_is(EQUAL_TO, 1, !{
                    input_choice2 += choice
                    std_in += auto_inputs2[choice]
                    input_char.move(-100 * auto_inputs2[choice], 0, 0)
                })

                call_with_delay(0.5, done)
            }



            for ch in 0..challenges {
                if auto_input_challenges.contains(ch) {
                    challenge.item.if_is(EQUAL_TO, ch, !{
                        input_used.item.if_is(SMALLER_THAN, 2, auto_input)
                        input_used.item.if_is(LARGER_THAN, 1, manual_input)
                    })
                } else {
                    challenge.item.if_is(EQUAL_TO, ch, manual_input)
                }
            }

            gs.button_a().on(!{
                suppress_signal(0.05)
                if input_mode == 1 {
                    -> input_inc_button.pulse(59, 144, 247, fade_out = 0.3)
                    std_in += 1
                    input_char.move(-100, 0, 0)
                }
            })
            gs.button_b().on(!{
                -> if input_mode == 1 {
                    input_mode -= 1
                    done!
                }
            })

        }
        -> if @bool(self.open) {
            move_to = !{
                -> 45c.set(prog_ptr_color[0] * 0.3, prog_ptr_color[1] * 0.3, prog_ptr_color[2] * 0.3, blending = true)
                //move to corresponding ]
                //layers = counter(0)
                condition = () => !(layers == 0 && self.close == 1) && ended == 0
                //self.group.move(spacing, 0)

                while_loop(condition, delay = 0.05, (){

                    
                    -> if self.open == 1{
                        layers += 1
                    }

                    -> if self.close == 1 {
                        layers -= 1
                    }

                    -> if self.end == 1 {

                        force_stop!
                    } else {
                        self.group.move(spacing, 0)
                        
                    }


                })
                -> 45c.set(prog_ptr_color[0], prog_ptr_color[1], prog_ptr_color[2], blending = true)
                ret!
            }
            if self.current_cell() == 0 {
                layers -= 1
                call_with_delay(0.05, move_to)
            } else {
                ret!
            }
        }
        -> if @bool(self.close) {
            move_back = !{
                -> 45c.set(prog_ptr_color[0] * 0.3, prog_ptr_color[1] * 0.3, prog_ptr_color[2] * 0.3, blending = true)
                //move back to corresponding [
                //layers = counter(0)
                condition = ()=> !(layers == 0 && self.open == 1) && ended == 0
                //self.group.move(-spacing, 0)

                //wait()
                while_loop(condition, delay = 0.05, (){
                    
                    -> if self.close == 1 {
                        layers += 1
                    }

                    -> if self.open == 1 {
                        layers -= 1
                    }
                    -> if self.end == 1 {

                        force_stop!
                    } else {
                        self.group.move(-spacing, 0)
                        
                    }
                })
                -> 45c.set(prog_ptr_color[0], prog_ptr_color[1], prog_ptr_color[2], blending = true)
                ret!
            }
            if self.current_cell() != 0 {
                layers -= 1
                call_with_delay(0.05, move_back)
            } else {
                ret!
            }
        }
        -> if @bool(self.noop) {
            fast_ret!
        }


    }
}
move_group_menu = 31g
move_group_game = 30g
move_group_tut = 32g

move_group_game.toggle_off()
move_group_tut.toggle_off()

roll_groups = 70g..110g


insert_bf_cmd = (ch: @string, offset: [@number], group: @group) {

    blockid = match ch {
        ==">": RIGHT,//increment the data pointer (to point to the next cell to the right).
        =="<": LEFT,	//decrement the data pointer (to point to the next cell to the left).
        =="+": INCR,	//increment (increase by one) the byte at the data pointer.
        =="-": DECR,	//decrement (decrease by one) the byte at the data pointer.
        ==".": DOT,	//output the byte at the data pointer.
        ==",": INPUT,//accept one byte of input, storing its value in the byte at the data pointer.
        =="[": OPEN,
        =="]": CLOSE,
        =="end": END,
        =="no\nop": NOOP,

    }


    $.add(obj {
        OBJ_ID: 1816,
        X: offset[0],
        Y: offset[1],
        BLOCK_A: blockid,
        GROUPS: [group, gs.hidden_group],
        SCALING: 0.5,
    })
    // let scale
    // let color
    // if ch.length == 1 {
    //     scale = 0.8
    // } else {
    //     scale = 0.3
    // }
    // if blockid == NOOP {
    //     color = 2c
    // } else {
    //     color = 40c
    // }
    // $.add(obj {
    //     OBJ_ID: 914,
    //     X: offset[0] + 41 * 30 - 1200,
    //     Y: offset[1] - 8.6 * 30 - 600,
    //     TEXT: $.b64encrypt(ch),
    //     GROUPS: [group, 968g, move_group],
    //     SCALING: scale,
    //     COLOR: color,
    //     EDITOR_LAYER_1: 3,
    //     Z_LAYER: 1
    // })
}

offset = [1500, 900]
sel_off = [600, 1500]

commands = 40

selector = {block: ?b, group: ?g, start: ?g}



$.add(obj {
    OBJ_ID: 1765,
    X: sel_off[0] - 60,
    Y: sel_off[1] - 60,
    GROUPS: [selector.start, gs.hidden_group],
})

$.add(obj {
    OBJ_ID: 1816,
    X: sel_off[0] - 60,
    Y: sel_off[1] - 60,
    BLOCK_A: selector.block,
    GROUPS: [selector.group, gs.hidden_group],
    DYNAMIC_BLOCK: true,
})

is_running = counter(0)
block_input = counter(0)


reset_selector = ?b


command_end = 665g
command_end_block = 666g

for i in ..3 {
    $.add(obj {
        OBJ_ID: 1816,
        X: sel_off[0] + commands * 60,
        Y: sel_off[1] - 30 * i,
        BLOCK_A: reset_selector,
        GROUPS: [gs.hidden_group, command_end_block],
        SCALING: 0.5,
    })
}
reset_selector_func = !{
    block_input += 1
    -> 952g.move_to(953g, 0.5, x_only = true, easing = EASE_IN_OUT)
    -> selector.group.move(-10, 0, 0.09, EASE_IN_OUT)
    wait(0.1)
    prog_selector.follow(selector.group, duration = 0.15, x_mod = 0.5)
    wait(0.01)
    -> selector.group.move_to(selector.start, 0.1, easing = EASE_IN_OUT)
    prog_selector.move(-5, 0, 0.1, easing = EASE_IN_OUT)
    block_input -= 1



    activate_button(195c, 196c)

}

y_spacing = 20


// end
$.add(obj {
    OBJ_ID: 1816,
    X:  offset[0] + commands * spacing * 3,
    Y:  offset[1],
    BLOCK_A: END,
    SCALING: 0.2,
    GROUPS: [gs.hidden_group, command_end]
})

$.add(obj {
    OBJ_ID: 1816,
    X:  offset[0] - spacing * 3,
    Y:  offset[1],
    BLOCK_A: END,
    SCALING: 0.2,
    GROUPS: [gs.hidden_group]
})

//run button

// block that runs the thing
run_block = ?b
for j in ..10 {
    $.add(obj {
        OBJ_ID: 1816,
        X: sel_off[0] - 60,
        Y: sel_off[1] + 30 * j,
        BLOCK_A: run_block,
        SCALING: 0.5,
        GROUPS: gs.hidden_group
    })
}
force_quit_taps = counter(56i)
//force_quit_taps.display(90, 0)

reader = @bfreader::new(offset, 6)
prog_pointer.follow(reader.group)



-> move_group_menu.move(-235, 100, 0)
-> move_group_game.move(-235 -1100, 100, 0)
-> move_group_tut.move(-235, -60, 0)
menu_follow = !{
    move_group_menu.follow(981g)
}
menu_follow!





all = (arr) {
    for item in arr {
        if !@bool(item) {
            return false
        }
    }
    return true
}

// for i in 0..3 {
//     reader.std_out.win[i].display(60 + i * 30, 60)
// }

// for i in 0..4 {
//     reader.std_out.coin[i].display(60 + i * 30, 90)
// }

// for i in 0..4 {
//     reader.std_out.coin_coin[i].display(60 + i * 30, 120)
// }



for i in ..commands {
    sg = roll_groups[i]
    c = counter(0)
    //c.display(sel_off[0] + i * 60, sel_off[1] + 30)
    order = ["no\nop","+","-","<",">","[","]",".",",","end"]
    for c in ..order.length {
        off = [offset[0] + i * spacing * 3, offset[1] + c * y_spacing * 3]
        insert_bf_cmd(order[c], off, sg)
    }
    // block that increments the selector
    inc_block = ?b
    for j in ..19 {
        $.add(obj {
            OBJ_ID: 1816,
            X: sel_off[0] + i * 60,
            Y: sel_off[1] + j * 30,
            BLOCK_A: inc_block,
            SCALING: 1,
            GROUPS: gs.hidden_group
        })
    }

    // block that checks for end
    end_check_block = ?b
    $.add(obj {
        OBJ_ID: 1816,
        X: sel_off[0] + i * 60 + 30,
        Y: sel_off[1] - 60,
        BLOCK_A: end_check_block,
        SCALING: 0.5,
        GROUPS: gs.hidden_group
    })

    // block that resets the selector
    reset_block = ?b
    $.add(obj {
        OBJ_ID: 1816,
        X: offset[0] + i * spacing * 3,
        Y: offset[1] - order.length * y_spacing * 3 + 10,
        BLOCK_A: reset_block,
        DYNAMIC_BLOCK: true,
        SCALING: 1,
        GROUPS: gs.hidden_group
    })

    collision(end_check_block, selector.block).on(!{c.item.if_is(EQUAL_TO, order.length - 1, reset_selector_func)})

    collision(inc_block, selector.block).on(!{
        sg.move(0, -y_spacing, 0)
        c += 1
    })

    collision(NOOP, reset_block).on(!{
        sg.move(0, y_spacing * order.length, 0)
        c -= order.length
    })

}

collision(130b, 131b).on(!{
    952g.move(-20, 0, 0.3, easing = EASE_IN_OUT)
})

collision(130b, 132b).on(!{
    952g.move(-60, 0, 0.3, easing = EASE_IN_OUT)
})


collision(130b, 166b).on(!{
    952g.move(30, 0, 0.3, easing = EASE_IN_OUT)
})

coin1 = 201g
coin2 = 202g
coin3 = 765g
end_wall = 200g
end_anim = 987g

coin1.toggle_off()
coin2.toggle_off()
coin3.toggle_off()
end_anim.toggle_off()


955g.toggle_off()

// bg1 = 867g
// bg2 = 868g
//bg2.toggle_off()
//-> bg2.move(-1000, 0, 0) //unload

game_bg_target = 908g
match_game_bg = 909g

random_affect = !{
    suppress_signal(0.2)
    -> if random_seed >= random_max - 1 {
        wait()
        random_seed -= random_max - 1
    } else {
        wait()
        random_seed += 1
    }

    -> if random_bg_seed >= bg_options - 1 {
        wait()
        random_bg_seed -= bg_options - 1
    } else {
        wait()
        random_bg_seed += 1
    }
}

while_loop(() => true, delay = 0.47, () {
    random_affect!
})

let match_to_bg = []
for bg in game_bgs {
    func = !{
        for g in game_bgs {
            if g != bg {
                g[2].stop()
                g[0].toggle_off()
            }
        }
        wait()
        -> bg[1].move_to(game_bg_target)
        bg[2]!
        bg[0].toggle_on()
    }
    match_to_bg.push(func)
}


$.extend_trigger_func(match_game_bg, (){
    option = [bg_option1, bg_option2][random_bg_seed.to_const(0..bg_options)]
    match_to_bg[option.to_const(0..game_bgs.length)]!
})

for g in game_bgs {
    g[0].follow(g[1])
    g[0].toggle_off()
    $.extend_trigger_func(g[2], (){
        g[1].follow(981g)
        g[0].follow(981g)
    })
}




tut_text_colors = 300c..800c

// challenge 0: run any program
// challenge 1: output 10
// challenge 2: output 40 no input
// challenge 3: double input
// challenge 4: add 2 inputs
// challenge 5: compare 2 inputs


// challenge ideas:
// write b if input > 10, else write s
// square input
// get nth fibonachi number

// coin 7: write "coin" using no input
// coin 8: write "coin coin" using no input

challenge_board = 203g
challenge_board_color = 203c

challenge_name_colors = 55c..65c
challenge_desc_colors = (65c..101c) + (181c..186c) + (218c..300c)
challenge_extra_info_colors = [186c, 188c]

next_challenge = !{
    challenge += 1

    -> challenge_board_color.pulse(81, 252, 95, fade_out = 0.5)
    -> 187c.pulse(0,0,0, fade_in = 0.4, hold = 0.2, fade_out = 0.6)
    -> 866g.move(-40, 0, 0.4, easing = EASE_IN_OUT)
    -> 865g.move(40, 0, 0.4, easing = EASE_IN_OUT)
    for i in ..challenge_name_colors.length {
        -> challenge_name_colors[i].pulse(0,0,0, fade_in = 0.4, hold = 0.1 + 0.06 * i)
    }
    for i in ..challenge_desc_colors.length {
        extra_delay = $.sin(i / 10) * 0.3
        -> challenge_desc_colors[i].pulse(0,0,0, fade_in = extra_delay + 0.1, hold = 2.0 + 0.03 * i - extra_delay, fade_out = 0.1)
    }

    for i in ..challenge_extra_info_colors.length {
        -> challenge_extra_info_colors[i].pulse(0,0,0, fade_in = 0.4, hold = 2.3 + i * 0.1, fade_out = 0.3)
    }

    wait(0.45)
    -> 866g.move(40, 0, 1.5, easing = EASE_IN)
    -> 865g.move(-40, 0, 1.5, easing = EASE_IN)
    -> challenge_board.move(-200, 0)

    -> if challenge == 6 {
        // limit commands
        -> command_end.move(-10 * 13, 0, 1, easing = EXPONENTIAL_OUT)
        -> command_end_block.move(-20 * 13, 0, 1, easing = EXPONENTIAL_OUT)
    }
    wait(3)
    reset_runs_in_a_row!
    -> if challenge == 4 {
        end_wall.toggle_off()
        end_anim.toggle_on()
        top_msg_board(1, [255, 255, 0])
    }
}

reset_env = !{
    for c in reader.cells {
        -> c.reset()
    }

    -> input_used -= input_used.to_const(1..3)

    -> reader.ptr.reset(for_each = (n) { cell_pointer.move(-10 * n, 0, 0.1, easing = EASE_IN_OUT) })
    -> reader.num_out.reset()
    -> reader.group.move_to(reader.start_point, 0)
    -> 952g.move_to(953g, 0.5, x_only = true, easing = EASE_IN_OUT)
    -> cell_pointer.move_to(reader.start_point, 0.3)
    -> force_quit_taps -= force_quit_taps.to_const(1..4)
    -> reader.std_out.reset()



}


start = (){





    call_with_delay(0.5, match_game_bg)

    collision(reset_selector, selector.block).on(reset_selector_func)


    touch().on(!{

        if ended == 1 {
            reset_env!

            bottom_msg_board_down()
            wait(0.2)
            activate_button(195c, null)
            activate_button(192c, null)
            954g.toggle_on() //prog selector collision enable
            955g.toggle_off()
            is_running -= 1
            block_input -= 1
            ended -= 1

        } else if is_running == 1 && reader.input != 1 {
            force_quit_taps.item.if_is(SMALLER_THAN, 3, !{
                force_quit_taps += 1
            })
            force_stop_layer.alpha(1, 0.5)
            force_stop_layer.alpha(0, 2)

        }
    })

    force_quit_taps.item.count(3).on(force_stop)

    output_correct = () {
        -> 217c.pulse(0, 255, 0, fade_out = 1)
        -> 800c.pulse(0, 255, 0, fade_out = 1)
        ended += 1
        bottom_msg_board_up()
    }

    output_correct_no_end = () {
        -> 217c.pulse(69, 255, 187, fade_out = 0.5)
        -> 800c.pulse(69, 255, 187, fade_out = 0.5)
    }

    output_wrong = !{
        -> 217c.pulse(255, 0, 0, fade_out = 1)
        -> 800c.pulse(255, 0, 0, fade_out = 1)
        ended += 1
        bottom_msg_board_up()
    }

    collision(run_block, selector.block).on(!{
        is_running += 1
        block_input += 1
        954g.toggle_off() //prog selector collision disable
        955g.toggle_on()
        // reader.num_out.add(10)
        // wait(0.1)
        // reader.std_out.write(reader.num_out)
        // wait(0.1)

        activate_button(null, 195c)
        activate_button(null, 192c)
        run = !{
            wait(0.1)
            reader.group.move(10, 0, 0.05)
            //-> BG.pulse(255, 0, 0, fade_out = 1)

            while_loop(()=> reader.end == 0 && force_quit_taps < 3, delay = 0.1, (){
                reader.interpret()
            })

            if force_quit_taps < 3 && ended == 0 {
                wrong_out = !{
                    output_wrong!
                    top_msg_board(0, [255, 0, 0])
                    reset_runs_in_a_row!
                }
                //-> finished_color.set(255, 255, 255, 0)
                -> if gamemode == 1 {
                    //challenges
                    -> if challenge == 0 {
                        call_with_delay(0.05, next_challenge)
                        bottom_msg_board_up()
                        ended += 1
                    }

                    -> if challenge == 1 {
                        if reader.num_out == 10 {
                            call_with_delay(0.05, next_challenge)
                            output_correct()
                        } else {

                            output_wrong!
                        }
                    }

                    -> if input_used == 0 {


                        -> if challenge == 2 {
                            if reader.num_out == 40 {
                                call_with_delay(0.05, next_challenge)
                                output_correct()
                            } else {
                                output_wrong!
                            }
                        }

                        challenge.item.if_is(EQUAL_TO, 3, wrong_out)

                        challenge.item.if_is(EQUAL_TO, 4, wrong_out)

                        challenge.item.if_is(EQUAL_TO, 5, wrong_out)

                        // -> if challenge == 6 {
                        //     if all(reader.std_out.win) {
                        //         call_with_delay(0.05, next_challenge)
                        //         output_correct()
                        //         top_msg_board(2, [255, 255, 0])
                        //     } else {
                        //         output_wrong!
                        //     }
                        // }


                        -> if all(reader.std_out.coin) {

                            -> if challenge == 6 {
                                coin1.toggle_on()
                                call_with_delay(0.05, next_challenge)
                                -> command_end.move(10 * 13, 2, 0, easing = EXPONENTIAL_IN)
                                -> command_end_block.move(20 * 13, 2, 0, easing = EXPONENTIAL_IN)
                                end_wall.toggle_off()
                                end_anim.toggle_on()
                                top_msg_board(2, [255, 255, 0])
                                output_correct()
                            }

                            -> if challenge == 7 {
                                if all(reader.std_out.coin_coin) {
                                    coin2.toggle_on()
                                    top_msg_board(2, [255, 255, 0])
                                    call_with_delay(0.05, next_challenge)
                                    output_correct()

                                } else {
                                    output_wrong!
                                }
                            }

                        } else {
                            -> if challenge == 6 {
                                output_wrong!
                            }

                            -> if challenge == 7 {
                                output_wrong!
                            }
                        }
                    } else {
                        //input challenges
                        inc_runs_in_a_row = !{

                            successful_runs += 1
                            -> 962g.move(-200, 0, 0)
                            messages[0].set(0,0,0,0)
                            wait()

                            -> if successful_runs == 3 {
                                -> if challenge == 5 {
                                    wait(4)
                                    top_msg_board(2, [255, 255, 0])
                                    coin3.toggle_on()
                                }
                                top_msg_board(0, [0, 255, 0])
                                call_with_delay(0.05, next_challenge)
                                output_correct()

                            } else {
                                top_msg_board(0, [255, 255, 255])
                                output_correct_no_end()
                                reset_env!
                                call_with_delay(0.3, run)
                            }
                        }



                        -> if input_used == 2 {
                            -> if challenge == 3 {
                                wrong_out!
                            }

                        }

                        -> if input_used == 1 {
                            -> if challenge == 4 {
                                wrong_out!
                            }

                            -> if challenge == 5 {
                                wrong_out!
                            }

                        }



                        input_choice.to_const_enclosed(..random_max, (choice) {
                            -> if challenge == 3 {
                                -> if input_used == 1 {
                                    -> if reader.num_out == auto_inputs[choice] * 2 {
                                        inc_runs_in_a_row!
                                    } else {
                                        wrong_out!
                                    }
                                }

                            }
                            -> if choice != 0 {
                                wait()
                                input_choice -= choice
                            }

                            -> if input_used == 2 {


                                input_choice2.to_const_enclosed(..random_max, (choice2) {
                                    -> if challenge == 4 {
                                        -> if reader.num_out == auto_inputs[choice] + auto_inputs2[choice2] {
                                            inc_runs_in_a_row!
                                        } else {
                                            wrong_out!
                                        }
                                    }

                                    -> if challenge == 5 {

                                        -> if reader.num_out == abs(auto_inputs[choice] - auto_inputs2[choice2]) {
                                            inc_runs_in_a_row!
                                        } else {
                                            wrong_out!
                                        }
                                    }

                                    -> if choice2 != 0 {
                                        wait()
                                        input_choice2 -= choice2
                                    }
                                })
                            }
                        })
                    }
                    -> if challenge > 7 {
                        bottom_msg_board_up()
                        ended += 1
                    }


                    //wait(0.2)
                } else {
                    bottom_msg_board_up()
                    ended += 1
                }
            }
        }

        run!
        //call_with_delay(999, run)


    })


}
8c.set(0, 0, 0)
// start menu
gm_selector = 50g
menu_timer = 51g
gm_name_colors = 20c..29c
allow_menu_move = counter(0)
//212c
// follow group shit
game_match = ?g //group that toggles the triggers that match to ingame
tut_match = ?g //group that toggles the triggers that match to ingame
match_spacing = 150
game_match.toggle_off()
tut_match.toggle_off()

start_func = !{
    activate_button(195c, 191c)

    move_group_game.toggle_on()
    game_match.toggle_off()



    move_group_game.follow(981g)
    -> 54c.set(0,0,0, 0.5, opacity = 0.0)
    -> 900g.move(0, 33, 0)
    -> 903g.move(0, -150, 0)
    //-> BG.pulse(255, 0, 0, fade_out = 0.6)



    -> $.add( trigger{
        OBJ_ID: 1268,
        SPAWN_DURATION: 3,
        TARGET: !{
            top_msg_board(4, [112, 215, 255])
        },
        HIGH_DETAIL: true,
    })

    start()
}

tut_text_anim_finished = counter(200i)

for col in tut_text_colors {
    -> col.set(255,0,0)
}

tut_letters = !{
    activate_button(194c, 192c)
    delta = 0.05
    for i in 0..tut_text_colors.length {
        -> tut_text_colors[i].pulse(0,0,0, fade_in = 0.4, hold = 0.2 + i * delta, exclusive = true)
    }

    -> 197c.pulse(0,0,0, fade_in = 0.4, hold = 0.2 + 131 * delta, fade_out = 0.5, exclusive = true)
    -> 198c.pulse(0,0,0, fade_in = 0.4, hold = 0.2 + 193 * delta, fade_out = 0.5, exclusive = true)
    -> 199c.pulse(0,0,0, fade_in = 0.4, hold = 0.2 + 266 * delta, fade_out = 0.5, exclusive = true)
    -> 200c.pulse(0,0,0, fade_in = 0.4, hold = 0.2 + 0 * delta, fade_out = 0.5, exclusive = true)
    -> 211c.pulse(0,0,0, fade_in = 0.4, hold = 0.2 + 68 * delta, fade_out = 0.5, exclusive = true)
    -> 213c.pulse(0,0,0, fade_in = 0.4, hold = 0.2 + 450 * delta, fade_out = 0.5, exclusive = true)

    //wait()
    tut_text_anim_finished.item.if_is(EQUAL_TO, 1, !{
        tut_text_anim_finished -= 1
    })
    wait(delta * 300)
    tut_text_anim_finished.item.if_is(EQUAL_TO, 0, !{
        tut_text_anim_finished += 1
        if tut_page_num < tut_pages - 1 {
            activate_button(192c, 194c)
        } else {
            activate_button(212c, 194c)
        }
    })
}

tut_func = !{
    move_group_tut.toggle_on()
    tut_match.toggle_off()
    -> 54c.set(0,0,0, 0.5, opacity = 0.0)

    move_group_tut.follow(981g)
    //-> BG.pulse(255, 0, 0, fade_out = 0.6)
    delta = 0.05
    for i in 0..tut_text_colors.length {
        -> tut_text_colors[i].pulse(0,0,0, fade_in = 0, hold = 0.2 + i * delta)
    }
    tut_text_anim_finished += 1
    activate_button(null, 191c)
    activate_button(192c, null)



}



for i in 5..669 {
    //game
    $.add( obj{
        X: match_spacing * i - 2,
        Y: -15,
        OBJ_ID: 901,
        TARGET: move_group_game,
        MOVE_X: i * match_spacing,
        DURATION: 0,
        GROUPS: game_match,
    })
    $.add( obj{
        X: match_spacing * i,
        Y: -45,
        OBJ_ID: 1268,
        SPAWN_DURATION: 0,
        TARGET: start_func,
        GROUPS: game_match,
    })

    //tut
    $.add( obj{
        X: match_spacing * i - 2,
        Y: -15 - 90,
        OBJ_ID: 901,
        TARGET: move_group_tut,
        MOVE_X: i * match_spacing,
        DURATION: 0,
        GROUPS: tut_match,
    })
    $.add( obj{
        X: match_spacing * i,
        Y: -45 - 90,
        OBJ_ID: 1268,
        SPAWN_DURATION: 0,
        TARGET: tut_func,
        GROUPS: tut_match,
    })
}
// added this because compiler stupid and im too lazy to fix

wait(2.5)




tut_transition = (dir){
    // seglen = tut_text_colors.length / 3
    // part1 = 0..seglen
    // part2 = part1.end..(part1.end + seglen)
    // part3 = part2.end..(part2.end + seglen)

    tut_letters!


    if dir != 0 {
        wait(0.4)
        tut_page.move(300 * -dir, 0, 0)
        tut_page_num.add(dir)
    }
}


right_button = 901g
left_button = 902g

// tutorial animations

inc_item = 501i
decr_item = 502i
decr_item.add(100)

tut_arrow_items = 503i..508i
for i in ..tut_arrow_items.length {
    tut_arrow_items[i].add(i)
}


gs.button_a().on(!{

    -> right_button.move(0, -2, 0.1, easing = EASE_OUT, easing_rate = 4)
    -> right_button.move(0, 2, 0.4, easing = EASE_IN_OUT, easing_rate = 3)
    -> right_button.pulse(0, 0, 2, fade_out = 0.5, hsv = true)
    random_affect!

    -> if started == 0 && allow_menu_move == 0 {

        wait()
        allow_menu_move += 1
        -> 53c.set(255, 255, 255)
        -> 53c.set(0, 0, 0, 0.4)
        -> 937g.move(10, 10, 0.5, easing = EXPONENTIAL_OUT)
        -> 938g.move(-10, -10, 0.5, easing = EXPONENTIAL_OUT)
        wait(0.3)
        54c.set(0,0,0, 0.5)

        started += 1
        -> if gamemode == 0 {
            //tutorial setup
            move_group_menu.toggle_off()
            menu_follow.start_group.stop()
            //move_group.move(0, -160, 0)
            tut_match.toggle_on()

            -> while_loop(() => gamemode == 0, delay = 1, () {
                inc_item.add(1)
                -> if counter(decr_item) > 0 {
                    decr_item.add(-1)
                }

                -> 939g.pulse(100, 2.0, 2.0, fade_out = 0.5, hsv = true)
                pulse_ptr()
                -> () {

                    -> 932g.move(10, 0, 0.3)
                    -> 935g.move(-10, 0, 0.3)
                    -> 933g.move(-10, 0, 1)
                    -> 934g.move(10, 0, 1)
                    wait(1)

                    933g.move(10, 0, 0)
                    932g.move(-10, 0, 0)
                    934g.move(-10, 0, 0)
                    935g.move(10, 0, 0)
                    for item in tut_arrow_items {
                        -> if counter(item) < 99 {
                            item.add(1)
                        }
                    }
                }()
            })

        }







        -> if gamemode == 1 {
            // challenge setup


            move_group_menu.toggle_off()
            menu_follow.start_group.stop()

            challenge -= 1
            call_with_delay(0.05, next_challenge)
            //move_group.move(-1100, 0, 0)
            game_match.toggle_on()


        }
        -> if gamemode == 2 {
            // coins setup


            move_group_menu.toggle_off()
            menu_follow.start_group.stop()
            first_coin_challenge = 6
            -> 810c.set(0,0,0)
            challenge += first_coin_challenge - 1
            call_with_delay(0.05, next_challenge)
            //move_group.move(-1100, 0, 0)
            challenge_board.move(-200 * first_coin_challenge, 0)
            wait()
            gamemode -= 1
            game_match.toggle_on()



        }


        -> if gamemode == 3 {
            // sandbox setup


            move_group_menu.toggle_off()
            menu_follow.start_group.stop()

            //-> bg2.move(1000, 0, 0) //reload
            //move_group.move(-1100, 0, 0)
            game_match.toggle_on()



        }



    } else {

        -> if gamemode == 0 {

            tut_page_num.item.if_is(EQUAL_TO, 1, !{
                activate_button(null, 193c)
            })

            tut_page_num.item.if_is(LARGER_THAN, 0, !{
                -> tut_transition(-1)
                activate_button(null, 212c)
            })

        } else {
            -> if block_input == 0 {

                selector.group.move(0, 20, 0)
                wait(0.03)
                selector.group.move(0, -20, 0)
            }
        }
    }
})

gs.button_b().on(!{
    -> left_button.move(0, -2, 0.1, easing = EASE_OUT, easing_rate = 4)
    -> left_button.move(0, 2, 0.4, easing = EASE_IN_OUT, easing_rate = 3)
    -> left_button.pulse(0, 0, 2, fade_out = 0.5, hsv = true)
    random_affect!

    -> if started == 0 && allow_menu_move == 0 {
        -> 985g.move(0, -1500, 0)
        -> 985g.move(0, 1500, 0.8)
        -> 15c.set(0,0,0, 0.1)
        wait()
        allow_menu_move += 1
        -> 978g.move(-80, 10, 0.5, easing = EASE_IN_OUT, easing_rate = 3.0)
        -> 977g.move(-60, -10, 0.5, easing = EASE_IN_OUT, easing_rate = 3.0)
        -> 7c.set(0, 0, 0, 0.4)
        -> 8c.set(255, 255, 255, 0.4)
        for i in ..gm_name_colors.length {
            -> gm_name_colors[i].pulse(0,0,0, fade_in = 0.4, hold = 0.1 + 0.06 * i)
        }

        wait(0.5)
        -> 15c.set(255,255,255, 0)
        allow_menu_move -= 1
        -> if gamemode == 3 {
            wait()
            gamemode -= 3
            gm_selector.move(600, 0, 0)
        } else {
            wait()
            gamemode += 1
            gm_selector.move(-200, 0, 0)
        }


        -> 978g.move(80, -10, 0)
        -> 977g.move(60, 10, 0)
        -> 8c.set(0, 0, 0)
        -> 7c.set(255, 255, 255)

    } else {
        -> if gamemode == 0 {
            tut_text_anim_finished.item.if_is(EQUAL_TO, 0, !{
                tut_letters.start_group.stop()
                if tut_page_num < tut_pages - 1 {
                    activate_button(192c, 194c)
                } else {
                    activate_button(212c, 194c)
                }
                wait()
                tut_text_anim_finished += 1
            })
            tut_text_anim_finished.item.if_is(EQUAL_TO, 1, !{
                if tut_page_num < tut_pages - 1 {
                    activate_button(193c, null)
                    -> tut_transition(1)
                } else {
                    //stop double tap


                    suppress_signal_forever()
                    tut_page_num.add(1)
                    54c.set(0,0,0, 0.5)
                    activate_button(null, 193c)
                    activate_button(192c, 212c)
                    gamemode += 1

                    tut_func.start_group.stop()
                    move_group_tut.toggle_off()

                    challenge -= 1
                    call_with_delay(0.05, next_challenge)
                    //move_group.move(-1100, 0, 0)
                    game_match.toggle_on()
                }
            })


        } else {

            if block_input == 0 {
                -> move_button.pulse(59, 144, 247, fade_out = 0.3)
                selector.group.move(20, 0, 0.1)
                prog_selector.move(10, 0, 0.1)

                //-> 905g.move(0, -150, 0)
                activate_button(196c, 195c)
            }
        }
    }

})

// +++.[->+++++>+++<<]>.>.[->++<]<-.>>++.+.

// +++.[->+++++>+++<<]>.>.<-.
// +++.++++++++++++.------.+++++.
